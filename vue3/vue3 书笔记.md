- vue3.0是一个运行时+编译时的框架
- 声明式代码的性能不优于命令式代码的性能
    - 声明式代码的性能消耗 = 直接修改的性能消耗 + 找出差异的性能消耗
    - 框架本身就是封装了命令式代码才实现了面向用户的声明式
    - 声明式的代码可维护性更强
    - 在保持可维护性的同时，让性能损失最小化
    - 虚拟DOM就是为了最小化找到差异出现的
- 打包后文件，判断环境有利于做tree-shaking
    - iife 格式，立即执行函数，引入即执行，全局变量vue
    - Es-bundler： 给打包工具使用的包，判断环境通过process.env.NODE_ENV !== "production"
    - esm-browser：<script type=“module” >使用，根据环境的不同，剋发环境__DEV__ 为true, 生产环境为false
    - cjs(即格式为 CommonJs)：主要是服务端渲染使用
- 设置__VUE_OPTIONS_API__： false，打包减少体积
- 使用javascript对象描述UI的方式就是虚拟DOM
- 组件就是一组DOM元素的封装
- Vue 编译器 将模板编译成渲染函数，并添加到script中
- Vue 渲染器 将虚拟DOM 渲染成真实DOM

- 编译器是可以识别哪些是静态属性，哪些是动态属性的，有助于渲染器去优化找出差异的性能

响应式：
- 读取时，将依赖收集起来
- 当设置时，将依赖取出并执行

名词：
- activeEffect：全局变量，存储被注册的副作用函数
    - deps：set数组
    - Options：{
      <!-- 调度函数 -->
      <!-- lazy -->
    }
- effectStack： effect栈，在调用副作用喊出之前将副作用函数压入栈，执行完之后，在pop，activeEffect重新指向栈顶的副作用函数
- 如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行

响应式系统在连续修改，只会做最后的更新，是因为内部使用了队列 Set保存副作用函数，在调度函数中add，因为set自动去重，所以就相同的副作用函数只会存在一次。又使用promise微任务，使当前更新只需要在最后执行就好，所以就达到了频繁修改值后只会更新最后一次的效果

- 调度器：响应式数据变化是，会调用调度器。相当于一个回调函数


Computed：
- getter：作为一个副作用函数，options：lazy: true只在读取时执行，新增dirty（控制副作用函数是否执行），和value（缓存上一次执行的结果），这样就可以达到不用多次执行缓存值的效果。 - 因为有缓存，之后的读取都是第一次，这是有问题的，所以需要在调度器中手动设置dirty： true
- 在其他副作用函数中读取计算属性时，相当于时嵌套effect，因为effect的设计是不互相影响的，所以当计算属性更新时，没有办法触发上层effect的执行，所以在computed 的get中手动调用track，在调度器中手动调用trigger（调度器执行意味着computed内部的effect的执行，那么在这就应该是computed的值修改了，所以在这手动调用trigger）
watch：
- 利用的调度器的特性，控制执行时机
