
#### 三次握手

* 客户端发送SYN报文,发送一个序列号给服务端.此时客户端的状态变为SYN_SENT. (SYN=1,syn=x)
* 服务端所收到客户端的SYN报文，将客户端发送的序列号+1,作为自己的确认号发送给客户端,同时将自己的序列号发送给客户端.此时服务端状态变为SYN_RCVD(SYN=1,ACK=1,syn=y,ack=x+1)
* 客户端收到服务端的报文,将服务端发送的序列号+1作为自己的确认号,将服务端发送的确认号作为序列号发送确认报给服务端.此时客户端的状态变为ESTABLISHED(ACK=1,syn=x+1,ack=y+1).服务端收到后也变为ESTABLISHED状态

> 为什么需要三次握手而不是两次握手?
  若只是两次握手,客户端可以确认自己能发出报文,且能接收报文.但是服务端只能确认自己能接收报文,不能确认自己是否能发送报文.即发送的报文客户端是否能接收到

#### 四次挥手

* 客户端发送一个FIN报文,发送一个序列号给服务端,此时客户端状态变为FIN_WITE1（FIN=1,syn=x）
* 服务端收到客户端的FIN报文，发送一个ACK确认报文.将客户端的序列号+1,作为自己的确认号,同时将自己的序列号发送给客户端.此时服务端状态变为CLOSE_WITE(ACK=1,ack=x+1,syn=y)
* 服务端也想断开连接,服务端发送一个FIN报文,同时发送确认号,和自己的序列号.(FIN=1,ACK=1,ack=x+1,syn=w)
* 客户端收到FIN报文,发送一个确认报文.(ACK=1,ack=w+1,syn=x+1)

原型：每个函数都有 prototype 属性，该属性指向原型对象；使用原型对象的好处是所有对象实例共享它所包含的属性和方法。
原型链：主要解决了继承的问题；每个对象都拥有一个原型对象，通过__proto__ 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。

* URL解析: 解析url协议/域名/端口/路径/参数 。
* DNS查询： 即域名解析。根据域名去先去本地服务器查找是否有对应的IP地址（递归查询）。找不到就去根服务器去查找IP地址信息。根服务器会让你去指定的服务器查找（迭代查询）
* TCP连接： 请求之前需经过TCP3次握手连接。连接成功后即可请求
* http请求： 请求行/请求头/请求体
* 请求响应
* 页面渲染： 
  * 解析html,生成Dom树
  * 解析css,生成css规则树
  * 合并Dom树和css规则树生成render树
  * 布局render树，layout/reflow计算位置，大小
  * 绘制render树，paint 绘制页面像素信息
  * 浏览器将render树的各层信息发送给GPU，GPU将各层合成，呈现在屏幕上

flex-direction
flex-wrap
flex-flow
justify-content
align-items
align-content


order
flex-grow 0
flex-shrink 1
flex-basis 
flex
align-self
flex: 1; === flex: 1 1 auto;
6）域名解析过程
首先介绍两个概念：递归查询和迭代查询
（1）递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机。
（2）迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。

本地=》 根=》 顶级域名服务器 =》 权限域名服务器


小结TCP与UDP的区别：
1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

进程是资源分配的最小单位，线程是CPU调度的最小单位

* 线程在进程下行进（单纯的车厢无法运行）
* 一个进程可以包含多个线程（一辆火车可以有多个车厢）
* 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
* 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
* 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
* 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
* 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
* 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
* 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”
