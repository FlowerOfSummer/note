### 手撕代码合集
#### call/apply/bind
#### call
特性：
* 接受多个参数，一个是this，剩余的是函数的参数，以参数列表的形式（与apply唯一的不同）
* 会立即执行，临时改变this指向，只会修改一次
* 当第一个参数是null,和undefined时，this默认指向window
  ```js
  function myCall() {
    if(typeof this !== 'function') {
      throw TypeError('not function')
    }
    let [_this, ...args] = [...arguments];
    
    if(!_this) {
      _this = typeof window === 'undefined' ? global : window;
    }
    _this.fn = this;
    let res = _this.fn(...args);
    delete _this.fn;
    return res;
  }
  ```

#### apply
流程：
* 接受2个参数，第一个是this，第二个是函数参数，以数组的形式
* 会立即执行，临时改变this，只会修改一次
* 当第一个参数是null或者是undefined时，this指向window
  ```js
  function myApply() {
    if(typeof this !=== 'function') {
      throw TypeError('not function')
    }
    let [_this, args] = [...arguments];
    if(!_this) {
      _this = window || global;
    }
    _this.fn = this;
    const res = _this.fn(...args);
    delete _this.fn;
    return res;
  }
  ```
### bind
流程：
* 修改this
* 实现动态传参
* 兼容new 关键字
  ```js
  function myBind() {
    if(typeof this !== 'function') {
      throw TypeError('not function')
    }
    let [_this, ...args] = [...arguments];
    const self = this;
    return function F() {
      if(this instanceof F) {
        return new _this(...args, ...arguments)
      } else {
        return self.apply(_this, [...args, ...arguments])
      }
    }
  }
  ```
### 实现new关键字
流程：
* 创建一个新的对象obj
* 将对象和构造函数通过原型链连接
* 将构造函数的this绑定到新的obj
* 根据构造函数返回数据类型判断，是原始值就返回创建的obj,否则返回
  ```js
    function myNew(Fun, ...args) {
      let obj = {};
      obj.__proto__ = Fun.prototype;
      let res = Fun.apply(obj, args);
      return res instanceof Object ? res : obj; 
    }
  ```
### 实现instanceof关键字
instanceof 运算符用于检测构造函数的prototype是否出现在某个实例对象的原型链上
流程：
* 找到检测对象的原型对象
* 递归比较实例对象的原型对象和目标构造函数是否相等
* 返回值为true/false
  ```js
  function myInstanceof(left, right) {
    if(typeof left !== 'object' || left === null) return false;
    let proto = Object.getPrototypeOf(left);
    while(true) {
      if(proto === null) return false
      if(proto === right.prototype) return true
      proto = Object.getPrototypeOf(proto);
    }
  }
  ```
### 深拷贝
流程：
* 判断是不是对象或数组，不是直接return
* 判断是不是Date和RegExp对象，是直接return new Date(obj)/RegExp(obj)
* 递归copy
* 使用map缓存一下，避免陷入死循环
  ```js
  function myCloneDeep(obj, hash = new wakeMap()) {
    if(typeof obj !=== 'object' || obj === null) return obj;
    if(obj instanceof Date) return new Date(obj);
    if(obj instanceof RegExp) return new RegExp(obj);

    if(hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor();
    hash.set(obj, cloneObj);
    for(let prop in obj) {
      if(Object.hasOwnProperty(prop)) {
        cloneObj[prop] = myCloneDeep(obj[prop], hash)
      }
    }
    return cloneObj;
  }
  ```

### 实现一个基本的Event Bus
  ```js
  class myEventBus = {
    constructor() {
      this.events = this.event || new map()
    }
    addListener(type, fn) {
      if(!this.events.get(type)) {
        this.events.set(type, fn)
      }
    }
    emit(type, ...args) {
      let handle = this.events.get(type);
      habdle.apply(this, args)
    }
  }
  ```
  #### 防抖
```js
function debounce(fn, timeout) {
    let timer = null;
    return function() {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, arguments);
        }, timeout)
    }
}
```
#### 节流
```JS
function throttle(fn, timeout) {
    let flag = true;
    return function() {
        if(!flag) return;
        flag = false;
        setTimeout(() => {
            fn.apply(this, arguments);
            flag = true;
        }, timeout)
    }
}
```