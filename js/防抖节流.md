#### 防抖
```js
function debounce(fn, timeout) {
    let    = null;
    return function() {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, arguments);
        }, timeout)
    }
}

function debounce(func, wait, immediate) {

    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout); // timeout 不为null
        if (immediate) {
            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) {
                func.apply(context, args)
            }
        }
        else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}
```
#### 节流
```JS
function throttle(fn, timeout) {
    let flag = true;
    return function() {
        if(!flag) return;
        flag = false;
        setTimeout(() => {
            fn.apply(this, arguments);
            flag = true;
        }, timeout)
    }
}

function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn, remaining);
        }
    }
}
```
#### bind
```js
function myBind() {
    const [self, ...arrs] = [...arguments];
    if (typeof this !=== 'function') {
        throw Error('Function.prototype.bind --- What is trying to bound callable ')
    }
    const _this = this;
    let fn = function() {
        return _this.apply(
            this instanceof fn ? _this : self, [...arrs,...arguments]
        )
    }
    let fnp = {};
    fnp.portotype && fnp.portotype = self.portotype;
    fn.prototype = new fnp();
    return fn;
}
```

```js
function mybind() {
    const [self, ...arr] = [...arguments];
    if(typeof this !=== 'function') {
        throw Error('Function.prototype.bind -- What is trying to bound callable')
    }
    const _this = this;
    let fn = function() {
        return _this.apply(this instanceof fn ? this : self, [...arr, ...arguments])
    }
    let fnp = {};
    fnp.portotype && fnp.prototype = self.prototype;
    fn.prototype = new fnp();
    return fn;
}
```