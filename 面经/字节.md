#### 一面 （50分钟）

* 自我介绍
* 项目介绍
* rem 与em的区别
* url输入后发生了什么
* 域名解析过程
* 收到响应渲染过程
* TCP三次握手和四次挥手
* http与https的区别
* http头有哪些
* script  defer与async加载区别
* 原型/原型链
* vue3特性
* 数据双向绑定，vue2与vue3的区别。
* vue3生命周期变化
* js数据检测的方法有哪些，typeof与instanceof的区别
* 防抖与节流，用法，手写防抖
* 算法


- 响应式是什么，常用到什么方法？移动端呢？
- css权重 important
- vue的diff算法
- vue 组件传值
- 浏览器缓存
- 重构项目遇到了什么问题，做了什么，技术挑战
- 判断{}是对象 非arr，function等
- 设计模式，用到什么设计模式？发布订阅设计模式和观察者模式有什么区别？
- 跨域？为什么设置跨域？如何防止跨域？跨域是浏览器端的还是服务器端的？为啥要服务端去解决跨域？
- 服务端渲染，react，next为什么要用，优缺点？
<!-- 合并两个对象 -->
<!-- promise设计并发 -->

- 项目
- 重构
- 为什么迁移，迁移方案，为什么用copy
- 做了哪些性能优化？给你一个网页，如何分析解决性能问题。
- 懒加载和预加载。怎么判断
- 微前端是什么，解决了什么
- vue2-vue3 compensition api区别，用法，优缺点
- 说一下vue的高阶组件
- vue的插槽，及作用域插槽
- react的hooks，用了哪些，都是干什么的？

<!-- promise 并发控制，闭包形式 -->
标题
并发请求限制
//line=readline()
//print(line)
console.log('Hello World!');

function coutactArr(arr1, arr2) {
    const res = []
    for(let i=0;i<arr1.length;i++) {
        if(arr2[0] && arr1[i] > arr2[0]) {
            res.push(arr2[0])
            arr2.shift()
        }
        res.push(arr1[i])
    }
    if(arr2.length) {
        res = [...res,...arr2]
    }
    return res
}
function newLocalStorage() {
    const setItem = (val, timeout) => {
        if(timeout) {
            const strartTime = new Date().getTime() + timeout
            let str = Object.stringify(val)+ '_' + strartTime
            window.localStoryage.setItem('a',str)
        } else {
            window.localStoryage.setItem(Object.stringify(val))
        }
    }
    const getItem = () => {
        const val = window.localStoryage.getItem('a').split('_')
        const now = new Date().getTime()
        const time = val?.[1]
        if(time && time < now) {
            throw Error('数据已过期')
        } else {
            return val[0]
        }
        
    }
    
}
题目描述
【背景】​
一般浏览器会限制并发请求数，微信小程序之前也限制过最多请求不超过10个。​
现在，让我们来实现一下这个功能。​
【问题描述】​
实现这样一个函数scheduler，函数入参为并发最大次数。​
如下最终输出顺序： 2、3、 1、 4​
一开始，1、2两个任务进入队列​
500ms时，2完成，输出2，任务3进队​
800ms时，3完成，输出3，任务4进队​
1000ms时，1完成，输出1​
1200ms时，4完成，输出4​

// -----------------mock一些请求​
```js
function scheduler(num) {
    let count = 0;
    let req = []
    function start(promise) {
        return new Promise((resolve) => {
            promise().then((res) => {
                resolve(res)
            }).finally(() => {
                count--
                if(req.length) {
                    let current = req.shift()
                    start(current.req).then(res => {
                        current.fn(res)
                    })
                }
            })
        })
    }
    return function (promise) {
        return new Promise((resolve) => {
            count++;
            if(count <= num) {
                start(promise).then(res => {
                    resolve(res)
                }) 
            } else {
                req.push({req: promise, fn: resolve})
            }
        })
    }
}

const request1 = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(1);
    }, 1000);
  });

const request2 = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(2);
    }, 500);
  });
const request3 = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(3);
    }, 300);
  });
const request4 = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(4);
    }, 400);
  });


const addRequest = scheduler(2);
addRequest(request1).then(res => {
  console.log(res);
});
addRequest(request2).then(res => {
  console.log(res);
});
addRequest(request3).then(res => {
    
  console.log(res);
});
addRequest(request4).then(res => {
  console.log(res);
});
```
```js 


//line=readline()
//print(line)
// console.log('Hello World!');

// // 2 8 3 7 1 10
setTimeout(() => {

    console.log(1);

}, 0);

async function main1() {

    new Promise((resolve, reject) => {

        console.log(2);

        resolve();

    }).then(() => {

        console.log(3);

    })

    await main2();

    console.log(7);

}

function main2() {

    console.log(8);

}

main1();

setTimeout(() => {

    console.log(10);

}, 0);


const computeCount = (arr) => {
    let total = 0
    let count = 0
    for(let i=0;i<arr.length;i++) {
        if(arr[i].children) {
            count = 0
            count += computeCount(arr[i].children).count
            arr[i].count = count
            total += count
        } 
        if(arr[i].select === 1) {
            count ++
            total ++
        }
    }
    return {count, total}
}

function getall(resource) {
    resource.forEach(item => {
        if(item.children) {
            item.count = computeCount(item.children).total
        }
    })
    return resource
}
const data = [{
    "id": 1540000,
    "label": "流量",
    "children": [{
        "id": 33,
        "label": "开放平台推广渠道",
        "select": 0
    },
    {
        "id": 37,
        "label": "订单关联标识",
        "select": 0
    },
    {
        "id": 86,
        "label": "APP三级版本",
        "select": 0
    },
    {
        "id": 94,
        "label": "APP二级版本",
        "select": 0
    },
    {
        "id": 97,
        "label": "一级频道",
        "select": 0
    },
    {
        "id": 100,
        "label": "流量入口",
        "select": 1
    },
    {
        "id": 211,
        "label": "商家流量入口",
        "select": 0
    },
    {
        "id": 552,
        "label": "访客类型",
        "select": 0
    },
    {
        "id": 2574,
        "label": "用户定位蜂窝类型",
        "select": 0
    },
    {
        "id": 3302,
        "label": "资源类型",
        "select": 0
    },
    {
        "id": 5438,
        "label": "访问时段",
        "select": 0
    },
    {
        "id": 6481,
        "label": "商家满起送的可售套餐数区间",
        "select": 0
    },
    {
        "id": 6483,
        "label": "商品推荐理由覆盖率区间",
        "select": 0
    },
    {
        "id": 50000,
        "label": "流量来源",
        "children": [{
            "id": 34,
            "label": "平台(流量)",
            "select": 1,
            "children": [{
                "id": 90,
                "label": "平台(流量)",
                "select": 1
            },
            {
                "id": 91,
                "label": "终端大类(流量)",
                "select": 1
            },
            {
                "id": 92,
                "label": "终端类型(流量)",
                "select": 1
            }]
        },
        {
            "id": 35,
            "label": "终端大类(流量)",
            "select": 1
        },
        {
            "id": 36,
            "label": "终端类型(流量)",
            "select": 1
        }]
    },
    {
        "id": 2250000,
        "label": "新终端",
        "children": [{
            "id": 11041810,
            "label": "平台（即将下线）",
            "select": 1
        },
        {
            "id": 11041813,
            "label": "终端大类（新）",
            "select": 1
        },
        {
            "id": 11041816,
            "label": "终端类型（即将下线）",
            "select": 0
        }]
    },
    {
        "id": 2480000,
        "label": "卡片层级",
        "children": [{
            "id": 4257,
            "label": "卡片类型",
            "select": 1
        },
        {
            "id": 3293,
            "label": "主题类型",
            "select": 0
        }]
    },
    {
        "id": 2500000,
        "label": "事业部-部门",
        "children": [{
            "id": 11044371,
            "label": "资源位活动创建人所属事业部",
            "select": 0
        },
        {
            "id": 11058030,
            "label": "资源位活动创建人所属部门",
            "select": 0
        },
        {
            "id": 11044374,
            "label": "资源位活动创建人所属一级组",
            "select": 0
        },
        {
            "id": 11044553,
            "label": "资源位活动创建人所属二级组",
            "select": 0
        }]
    },
    {
        "id": 11041504,
        "label": "全局事件",
        "select": 0
    },
    {
        "id": 11041539,
        "label": "全局页面",
        "select": 0
    }]
}]

console.log(JSON.stringify(getall(data)))




