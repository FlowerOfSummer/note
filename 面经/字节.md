#### 一面 （50分钟）

* 自我介绍
* 项目介绍
* rem 与em的区别
* url输入后发生了什么
* 域名解析过程
* 收到响应渲染过程
* TCP三次握手和四次挥手
* http与https的区别
* http头有哪些
* script  defer与async加载区别
* 原型/原型链
* vue3特性
* 数据双向绑定，vue2与vue3的区别。
* vue3生命周期变化
* js数据检测的方法有哪些，typeof与instanceof的区别
* 防抖与节流，用法，手写防抖
* 算法


- 响应式是什么，常用到什么方法？移动端呢？
- css权重 important
- vue的diff算法
- vue 组件传值
- 浏览器缓存
- 重构项目遇到了什么问题，做了什么，技术挑战
- 判断{}是对象 非arr，function等
- 设计模式，用到什么设计模式？发布订阅设计模式和观察者模式有什么区别？
- 跨域？为什么设置跨域？如何防止跨域？跨域是浏览器端的还是服务器端的？为啥要服务端去解决跨域？
- 服务端渲染，react，next为什么要用，优缺点？
<!-- 合并两个对象 -->
<!-- promise设计并发 -->
```js
function sendRequest(url) {
  return new Promise((resolve, reject) => {
    // 发送接口请求的逻辑
    // 这里使用 setTimeout 模拟异步请求
    setTimeout(() => {
      resolve(`Response from ${url}`);
    }, Math.random() * 1000);
  });
}

function sendRequests(urls, concurrency) {
  const results = [];
  let currentIndex = 0;

  function sendNextRequest() {
    if (currentIndex >= urls.length) {
      return Promise.resolve();
    }

    const currentUrl = urls[currentIndex];
    currentIndex++;

    return sendRequest(currentUrl)
      .then(response => {
        results.push(response);
      })
      .finally(() => {
        return sendNextRequest();
      });
  }

  const requests = [];
  for (let i = 0; i < concurrency; i++) {
    requests.push(sendNextRequest());
  }

  return Promise.all(requests).then(() => results);
}

const urls = ['url1', 'url2', 'url3', 'url4', 'url5', 'url6'];
const concurrency = 3;

sendRequests(urls, concurrency)
  .then(results => {
    console.log(results);
  })
  .catch(error => {
    console.error(error);
  });
```